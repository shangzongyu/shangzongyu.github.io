## mitmproxy

https://docs.mitmproxy.org/stable/concepts/certificates/

## Proxychains

### Proxychains 和 proxychains-ng 的比较如下：

1. 项目背景：
   - Proxychains 是较早期的版本，停更已久。
   - Proxychains-ng（ng 表示 next generation，下一代）是 proxychains 的继任版本，持续维护和更新。
2. 功能和性能：
   - Proxychains-ng 在功能上对原始 proxychains 进行了增强，支持更多现代代理协议，配置更加灵活。
   - Proxychains-ng 具有更好的性能和稳定性，网络路由延迟更低，使用体验更佳。
   - 增强了错误处理和 DNS 通过代理解析等功能。
3. 配置和使用：
   - 两者都基于动态库预加载 (LD_PRELOAD) 机制拦截网络调用，实现代理转发。
   - proxychains-ng 提供更友好的配置选项和更强大的链式代理支持，比如随机链、动态链、严格链等多种代理链路策略。
4. 适用性：
   - 由于 proxychains-ng 是原始 proxychains 的继承和改进版本，建议使用 proxychains-ng，除非某些极端兼容性需求仍需用旧版。

总结：proxychains-ng 是 proxychains 的新一代版本，具备更好的性能、更多功能和更活跃的维护，通常更推荐使用 proxychains-ng 来替代旧的 proxychains.[reddit+4](https://www.reddit.com/r/HowToHack/comments/jv3br9/what_is_the_difference_between_proxychainsng_and/)​

1. [https://www.reddit.com/r/HowToHack/comments/jv3br9/what_is_the_difference_between_proxychainsng_and/](https://www.reddit.com/r/HowToHack/comments/jv3br9/what_is_the_difference_between_proxychainsng_and/)
2. [https://www.stationx.net/proxychains/](https://www.stationx.net/proxychains/)
3. [https://github.com/rofl0r/proxychains-ng](https://github.com/rofl0r/proxychains-ng)
4. [https://www.reddit.com/r/Kalilinux/comments/1511efj/what_is_the_difference_between_proxychains_and/](https://www.reddit.com/r/Kalilinux/comments/1511efj/what_is_the_difference_between_proxychains_and/)
5. [https://www.pyproxy.com/information/what-is-the-difference-between-proxychains-and-proxychains-ng.html](https://www.pyproxy.com/information/what-is-the-difference-between-proxychains-and-proxychains-ng.html)
6. [https://en.kali.tools/?p=290](https://en.kali.tools/?p=290)
7. [https://hackingarise20.home.blog/2019/06/09/package-tutorial-proxychains-ng/](https://hackingarise20.home.blog/2019/06/09/package-tutorial-proxychains-ng/)
8. [https://neoctobers.readthedocs.io/en/latest/rpi/proxychains.html](https://neoctobers.readthedocs.io/en/latest/rpi/proxychains.html)
9. [https://www.kali.org/tools/proxychains-ng/](https://www.kali.org/tools/proxychains-ng/)
10. [https://github.com/haad/proxychains](https://github.com/haad/proxychains)

## Proxychains 介绍

**Proxychains** 是一个强大的 Linux/Unix 命令行代理工具，能够强制任何应用程序的 TCP 连接通过 SOCKS4、SOCKS5 或 HTTP(S) 代理服务器进行转发。它提供了一种优雅的方案来为不原生支持代理的命令行工具添加代理功能。

### 核心特性

Proxychains 的主要特点包括：

- 支持多种代理类型混合链接，例如可将 SOCKS5、HTTP、SOCKS4 代理混合在一个链中
- 支持不同的链接策略：严格链(`strict_chain`)、动态链(`dynamic_chain`)、轮询链(`round_robin`)和随机链(`random_chain`)
- 支持 DNS 代理解析，防止 DNS 泄露
- 支持网络扫描工具（如 Nmap）和数据库工具（如 SQLMap）的代理转发
- 与 Tor 网络良好集成

## 使用方法

### 基本配置

首先需要配置 `/etc/proxychains4.conf` 或自定义配置文件：[3]

```conf
# 配置链策略（选择一个）
# dynamic_chain      # 动态链：失败时自动跳过
# strict_chain       # 严格链：一个失败则全部失败（默认）
# random_chain       # 随机链：随机选择代理
# round_robin_chain  # 轮询链：依次循环使用

# 配置代理列表，格式为：<协议> <IP> <端口> [用户名] [密码]
[ProxyList]
socks5 127.0.0.1 1080
http   192.168.1.1 8080
```

### 基本使用

最常见的用法是在命令前加上 `proxychains4` 前缀：

```sh
# 查看当前IP
curl ipinfo.io

# 通过代理查看IP
proxychains4 curl ipinfo.io

# 使用特定配置文件
proxychains4 -f /etc/proxychains-custom.conf curl example.com

# 代理各种工具
proxychains4 nmap -sT target.com
proxychains4 sqlmap -u "http://target.com"
proxychains4 ssh user@host
```

### 链策略说明

| 链策略              | 说明                                   | 适用场景              |
| ------------------- | -------------------------------------- | --------------------- |
| 严格链(strict)      | 按顺序使用所有代理，一个失败则全部失败 | 需要完整链路的场景    |
| 动态链(dynamic)     | 按顺序尝试代理，失败自动跳过           | 代理可靠性差的场景 |
| 轮询链(round_robin) | 按顺序循环使用代理                     | 负载均衡场景          |
| 随机链(random)      | 每次随机选择代理                       | 最大化匿名性[3]       |

## 实现原理详解

Proxychains 采用了巧妙的 **LD_PRELOAD 库预加载机制** 来实现对应用程序网络功能的拦截。[1]

### LD_PRELOAD 机制

在 Linux 动态链接加载过程中，`LD_PRELOAD` 环境变量允许在加载所有其他共享库**之前**预先加载自定义库。这使得 Proxychains 可以在应用程序调用标准 libc 网络函数前，用自己的版本替换它们。[4][1]

```bash
LD_PRELOAD=./libproxychains.so程序名
```

### 函数 Hook 原理

Proxychains 的核心是重新实现 libc 中的关键网络函数：[1]

**被 Hook 的函数包括**：

- `connect()` - TCP 连接建立
- `sendto()` - UDP 数据发送
- `gethostbyname()` - 域名解析
- `getaddrinfo()` - 地址解析
- `close()` - 连接关闭
- `getnameinfo()` - 反向 DNS 解析

Proxychains 将这些函数的实现编译到 `libproxychains.so` 共享库中。当通过 `LD_PRELOAD` 加载时，操作系统的动态链接器会优先使用 Proxychains 提供的版本。[1]

### 详细的调用流程

**1. 库加载阶段**

```c
// SETUP_SYM 宏用于获取原始函数地址
#define SETUP_SYM(X) do { if (!true_##X) true_##X = load_sym(#X, X); } while(0)
SETUP_SYM(connect);
SETUP_SYM(getaddrinfo);
```

**2. 符号解析阶段**

Proxychains 使用 `dlsym()` 函数与特殊的 `RTLD_NEXT` 伪句柄来获取原始（未被 Hook）的函数地址：[1]

```c
static void* load_sym(char* symname, void* proxyfunc) {
    void *funcptr = dlsym(RTLD_NEXT, symname);
    if (!funcptr) {
        fprintf(stderr, "Cannot load symbol '%s' %s\n", symname, dlerror());
        exit(1);
    }
    return funcptr;
}
```

`RTLD_NEXT` 会在当前库**之后**的搜索顺序中查找符号，确保找到真实的 libc 函数而不是 Hook 的版本。[1]

**3. 连接拦截阶段**

当应用程序调用 `connect()` 时，执行流程为：

```c
int connect(int sock, const struct sockaddr *addr, socklen_t len) {
    // 检查是否为 TCP 连接
    if (!((family == AF_INET || family == AF_INET6) && socktype == SOCK_STREAM)) {
        return true_connect(sock, addr, len);  // 非TCP流，走原始路径
    }

    // TCP 连接则转向代理处理
    ret = connect_proxy_chain(sock, dest_ip, port, proxychains_pd,
                             proxychains_proxy_count, ...);
}
```

**4. Proxychains 执行时设置**

当用户运行 `proxychains4 command` 时，Proxychains 包装脚本会：[1]

```c
char buf[...];
char *old_val = getenv("LD_PRELOAD");
snprintf(buf, sizeof(buf), "LD_PRELOAD=%s/libproxychains.so%s%s",
         prefix, old_val ? " " : "", old_val ? old_val : "");
putenv(buf);
execvp(argv[start_argv], &argv[start_argv]);  // 执行目标程序
```

### DNS 处理机制

Proxychains 提供了 `proxy_dns` 选项来通过代理解析 DNS。启用此选项时，DNS 查询也会通过代理链转发，防止 DNS 泄露导致的隐私问题。[3]

### 限制条件

**静态链接程序无法使用 Proxychains**：[1]

静态链接的程序（特别是用 Go 的标准编译器编译的程序）直接调用系统调用 `syscall(SYS_CONNECT)` 而不是 libc 的 `connect()` 函数，因此 Hook 无效。这也是为什么许多 Go 程序无法被 Proxychains 代理。

**解决方案**：使用 `gccgo` 编译器替代标准 Go 编译器，生成的程序会链接到 libc 的 `connect()` 函数，从而支持 Proxychains。[1]

## 最近功能发展

根据 2024-2025 年的趋势预测，Proxychains 及代理技术正向以下方向发展：[5]

量子抗性加密集成，增强抗审计能力

与边缘计算架构的深度融合

机器学习实时优化代理链路选择

增强对移动流量的支持

环保节能的代理基础设施

这表明 Proxychains 作为经典 Linux 代理工具，其核心机制虽然已成熟稳定，但相关生态仍在持续演进。

[1](https://void-shana.moe/posts/proxychains-ng)
[2](https://cloud.tencent.com/developer/article/1043765)
[3](https://www.stationx.net/proxychains/)
[4](https://liveoverflow.com/hooking-on-linux-with-ld_preload-pwn-adventure-3/)
[5](https://proxyempire.io/proxy-chaining/)
[6](https://blog.csdn.net/2302_79590880/article/details/143803530)
[7](https://blog.csdn.net/qq_40178878/article/details/115618387)
[8](https://echohn.github.io/2016/05/29/to-build-the-fullstack-tools-for-over-the-wall/)
[9](https://github.com/haad/proxychains)
[10](https://www.youtube.com/watch?v=KWwOU1z5E8E)
[11](https://www.usenix.org/legacy/event/atc10/tech/full_papers/Dacosta.pdf)
[12](https://blog.51cto.com/u_16213667/9192075)
[13](https://github.com/dtrugman/PreloadHook)
